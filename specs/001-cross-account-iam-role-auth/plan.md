# Implementation Plan: Cross-Account IAM Role Authentication

**Branch**: `001-cross-account-iam-role-auth` | **Date**: 2026-02-09 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-cross-account-iam-role-auth/spec.md`

## Summary

Enable Wave to authenticate to customer AWS ECR registries using AWS STS AssumeRole with IAM roles instead of static credentials. This provides more secure and auditable cross-account access by:
- Replacing long-lived static credentials with temporary credentials (1-hour TTL)
- Preventing confused deputy attacks via unique external ID per workspace
- Enabling instant access revocation by customers through IAM trust policy updates
- Providing complete audit trail via AWS CloudTrail

**Technical Approach**: Extend Wave's `AwsEcrService` to detect role ARN pattern in username field and automatically use STS AssumeRole instead of static credentials. Cache temporary credentials with proactive refresh (5-minute buffer before expiration) to minimize STS API calls while ensuring reliability. Maintain full backward compatibility with existing static credential authentication.

## Technical Context

**Language/Version**: Groovy with Java 21+, Micronaut 4.10.6 framework
**Primary Dependencies**: AWS SDK for Java 2.x (STS), Micronaut Reactor, Caffeine cache, Spock 2 (testing)
**Storage**: Redis (credential caching), no new database tables in Wave
**Testing**: Spock 2 framework, Testcontainers for integration tests, JaCoCo for coverage
**Target Platform**: JVM on Linux/macOS (Kubernetes for production), Docker container with Amazon Corretto 25
**Project Type**: Single microservice (Wave)
**Performance Goals**: >95% credential cache hit rate, <1000ms authentication latency (cache miss), <100ms (cache hit)
**Constraints**: <200ms p95 latency for cached requests, maintain backward compatibility, zero-downtime deployment
**Scale/Scope**: 10,000+ concurrent customer credential sessions, ~26 MB memory overhead for caching

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Alignment with Wave Constitution v1.0.0

✅ **Service-Oriented Architecture**: Changes isolated to `AwsEcrService` - clear single responsibility for AWS authentication. No controller changes, logic stays in service layer.

✅ **Container Platform Agnosticism**: No platform-specific assumptions. Works with any ECR registry regardless of underlying container runtime (Docker, Kubernetes, Singularity).

✅ **Ephemeral-First Design**: Temporary credentials are ephemeral by design (1-hour TTL). Credentials only cached in memory, never persisted to disk.

✅ **Proxy Transparency**: Internal authentication change, invisible to Docker clients. No changes to Registry v2 API compliance.

✅ **Async-by-Default Operations**: STS AssumeRole is I/O-bound external API call. Initial implementation uses synchronous SDK calls (simpler), but wrapped in reactive patterns for future async optimization if latency becomes issue.

✅ **Security Scanning Integration**: Not applicable - authentication change doesn't affect scanning workflow.

✅ **Multi-Platform Build Support**: Not applicable - no container build changes.

✅ **Data Layer Principles**: Uses Redis (via AwsEcrCache) for ephemeral credential caching. No database schema changes in Wave. Follows existing caching patterns with Caffeine.

✅ **Authentication & Authorization**: Enhances existing authentication with more secure role-based approach. No changes to JWT tokens, rate limiting, or pod identity.

✅ **Testing Requirements**: Full Spock 2 unit tests, Testcontainers integration tests, backward compatibility tests. JaCoCo coverage tracking.

✅ **Performance Standards**: Cache design ensures HTTP endpoints respond within 200ms p95 for cached credentials (same as existing). Cache hit rate >95% meets efficiency requirements.

✅ **Versioning Policy**: MINOR version bump (new capability, backward compatible).

**Verdict**: ✅ **APPROVED** - No constitution violations. Feature aligns with all Wave principles.

## Project Structure

### Documentation (this feature)

```text
specs/001-cross-account-iam-role-auth/
├── plan.md              # This file
├── research.md          # Technology choices, architecture decisions, Platform integration points
├── data-model.md        # AwsCreds and CachedEcrCredentials modifications
├── quickstart.md        # Developer setup and testing guide for all 8 user stories
├── contracts/
│   ├── sts-integration.md      # AWS STS AssumeRole API contract
│   └── service-interface.md    # AwsEcrService interface changes
└── tasks.md             # To be generated by /speckit.tasks
```

### Source Code (Wave repository)

```text
src/main/groovy/io/seqera/wave/service/aws/
├── AwsEcrService.groovy                # MODIFY: Add STS integration, role ARN detection
├── cache/
│   └── AwsEcrCache.groovy              # MODIFY: Add expiration tracking for temporary credentials
└── config/
    └── AwsStsConfig.groovy             # NEW: STS client factory bean

src/test/groovy/io/seqera/wave/service/aws/
├── AwsEcrServiceSpec.groovy            # MODIFY: Add role-based auth tests
├── AwsEcrCacheSpec.groovy              # MODIFY: Add credential expiration tests
└── AwsEcrIntegrationSpec.groovy        # MODIFY: Add end-to-end role-based auth tests

src/main/resources/
└── application.yml                     # MODIFY: Add STS client configuration (if needed)

build.gradle
└── dependencies                         # MODIFY: Add software.amazon.awssdk:sts (already added per git status)
```

**Structure Decision**: Single microservice (Wave) with service-layer modifications. This is Option 1 from template - standard Micronaut service structure with Groovy. All changes contained within `src/main/groovy/io/seqera/wave/service/aws/` package, following existing patterns. Tests mirror source structure in `src/test/groovy/`.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

No violations detected. Table intentionally left empty.

---

## Implementation Phases

### Phase 0: Research & Analysis ✅ COMPLETE

**Status**: Research completed in `research.md`

**Deliverables**:
- ✅ Technology choice: AWS SDK for Java 2.x STS client
- ✅ Architecture decision: Hybrid credential provider (static + session credentials)
- ✅ Caching strategy: Extend existing AwsEcrCache with expiration tracking
- ✅ Session token handling: Include in AwsCreds class and cache key
- ✅ Performance analysis: 5-minute refresh buffer, 1-hour session duration
- ✅ Platform integration points identified (AwsSecurityKeys extension required)

**Key Findings**:
- Role ARN detection via pattern matching (no API changes)
- External ID prevents confused deputy attacks
- Cache hit rate projection: 91-99% depending on pull frequency
- Memory overhead: 2.6 KB per customer credential = 26 MB for 10K customers (negligible)
- STS API rate: <1 call per 3.6 seconds for 1000 customers (well below AWS limits)

---

### Phase 1: Wave Core Implementation

**Goal**: Implement STS AssumeRole integration with credential caching and automatic refresh

#### Task 1.1: Modify AwsCreds Class

**File**: `src/main/groovy/io/seqera/wave/service/aws/AwsEcrService.groovy` (inner class, line ~58)

**Changes**:
```groovy
@Canonical
class AwsCreds {
    String accessKey
    String secretKey
    String sessionToken    // NEW - null for static credentials
    String region
    boolean ecrPublic

    String stableHash() {
        Hashing.sha256()
            .hashString("$accessKey:$secretKey:${sessionToken ?: ''}:$region:$ecrPublic", Charsets.UTF_8)
            .toString()
    }

    @Override
    String toString() {
        "AwsCreds(accessKey=${accessKey?.take(8)}..., " +
        "secretKey=[REDACTED], " +
        "sessionToken=${sessionToken ? '[REDACTED]' : 'null'}, " +
        "region=$region, ecrPublic=$ecrPublic)"
    }
}
```

**Test Coverage**:
- Unit test: `stableHash()` includes session token
- Unit test: `toString()` redacts sensitive fields
- Unit test: Null session token handled correctly

---

#### Task 1.2: Modify CachedEcrCredentials Class

**File**: `src/main/groovy/io/seqera/wave/service/aws/cache/AwsEcrCache.groovy`

**Changes**:
```groovy
@Canonical
class CachedEcrCredentials {
    String accessKeyId
    String secretAccessKey
    String sessionToken        // NEW - null for static credentials
    Instant stsExpiration      // NEW - when STS credentials expire
    String authToken
    Instant tokenExpiration

    boolean isExpiring() {
        def now = Instant.now()
        def buffer = Duration.ofMinutes(5)

        // Check STS credential expiration (role-based)
        if (stsExpiration != null && now.plus(buffer).isAfter(stsExpiration)) {
            return true
        }

        // Check ECR token expiration (both auth types)
        return now.plus(buffer).isAfter(tokenExpiration)
    }

    Instant getEffectiveExpiration() {
        if (stsExpiration == null) {
            return tokenExpiration
        }
        return stsExpiration.isBefore(tokenExpiration) ? stsExpiration : tokenExpiration
    }
}
```

**Test Coverage**:
- Unit test: `isExpiring()` returns true when <5 min to STS expiration
- Unit test: `isExpiring()` returns true when <5 min to token expiration
- Unit test: `isExpiring()` returns false when >5 min remaining
- Unit test: `getEffectiveExpiration()` returns earliest expiration

---

#### Task 1.3: Create STS Client Bean

**File**: `src/main/groovy/io/seqera/wave/service/aws/config/AwsStsConfig.groovy` (NEW)

**Implementation**:
```groovy
package io.seqera.wave.service.aws.config

import io.micronaut.context.annotation.Factory
import jakarta.inject.Singleton
import software.amazon.awssdk.regions.Region
import software.amazon.awssdk.services.sts.StsClient

@Factory
class AwsStsConfig {

    @Singleton
    StsClient stsClient() {
        return StsClient.builder()
            .region(Region.AWS_GLOBAL)
            .build()
    }
}
```

**Configuration**: Uses AWS SDK default credential provider chain (environment variables, EC2 instance profile, etc.)

---

#### Task 1.4: Add Role ARN Detection to AwsEcrService

**File**: `src/main/groovy/io/seqera/wave/service/aws/AwsEcrService.groovy`

**New Private Method**:
```groovy
private boolean isRoleArn(String username) {
    return username?.matches(/^arn:aws:iam::\d{12}:role\/.+/)
}
```

**Test Coverage**:
- Unit test: Valid role ARN returns true
- Unit test: Access key ID returns false
- Unit test: Null returns false
- Unit test: Invalid ARN format returns false

---

#### Task 1.5: Implement STS AssumeRole Method

**File**: `src/main/groovy/io/seqera/wave/service/aws/AwsEcrService.groovy`

**New Private Method**:
```groovy
@Inject StsClient stsClient  // Add field injection

private AssumeRoleResponse assumeRole(String roleArn, String externalId, String sessionName) {
    AssumeRoleRequest request = AssumeRoleRequest.builder()
        .roleArn(roleArn)
        .roleSessionName(sessionName)
        .externalId(externalId)
        .durationSeconds(3600)
        .build()

    try {
        return stsClient.assumeRole(request)
    } catch (StsException e) {
        throw mapStsException(e, roleArn)
    }
}

private WaveException mapStsException(StsException e, String roleArn) {
    switch (e.awsErrorDetails().errorCode()) {
        case 'AccessDenied':
            return new UnauthorizedException(
                "Wave's service role cannot assume the specified IAM role. " +
                "Verify the trust policy allows Wave's service role and includes the correct external ID.",
                e
            )
        case 'InvalidParameterValue':
            return new BadRequestException(
                "Invalid role ARN or external ID format: ${e.awsErrorDetails().errorMessage()}",
                e
            )
        case 'RegionDisabledException':
            return new BadRequestException(
                "STS is not enabled in the specified region. Enable STS endpoints for this region in your AWS account.",
                e
            )
        default:
            return new WaveException("STS AssumeRole failed: ${e.awsErrorDetails().errorMessage()}", e)
    }
}

private String generateSessionName(String registry) {
    def matcher = registry =~ /^(\d{12})\.dkr\.ecr\./
    if (matcher) {
        return "wave-ecr-${matcher[0][1]}-${System.currentTimeMillis()}"
    }
    return "wave-ecr-access-${System.currentTimeMillis()}"
}
```

**Test Coverage**:
- Unit test: Successful AssumeRole returns response
- Unit test: AccessDenied throws UnauthorizedException
- Unit test: InvalidParameterValue throws BadRequestException
- Unit test: RegionDisabledException throws BadRequestException
- Unit test: Session name format is correct

---

#### Task 1.6: Modify getLoginToken Method

**File**: `src/main/groovy/io/seqera/wave/service/aws/AwsEcrService.groovy` (line ~91)

**Modified Logic**:
```groovy
String getLoginToken(String registry, String username, String password) {
    // NEW: Detect authentication type
    if (isRoleArn(username)) {
        log.debug("Detected role ARN, using STS AssumeRole authentication")
        return getLoginTokenWithRole(registry, username, password)
    } else {
        log.debug("Detected access key ID, using static credential authentication")
        return getLoginTokenWithStaticCredentials(registry, username, password)
    }
}

private String getLoginTokenWithRole(String registry, String roleArn, String externalId) {
    String region = extractRegion(registry)
    String sessionName = generateSessionName(registry)

    // Check cache first
    AwsCreds creds = new AwsCreds(
        accessKey: null,  // Placeholder, will be filled after AssumeRole
        secretKey: null,
        sessionToken: null,
        region: region,
        ecrPublic: isEcrPublic(registry)
    )

    // Get cached or load credentials
    CachedEcrCredentials cached = ecrCache.get(creds.stableHash()) { key ->
        // Assume role
        AssumeRoleResponse response = assumeRole(roleArn, externalId, sessionName)
        Credentials tempCreds = response.credentials()

        // Create AwsCreds with temporary credentials
        AwsCreds awsCreds = new AwsCreds(
            accessKey: tempCreds.accessKeyId(),
            secretKey: tempCreds.secretAccessKey(),
            sessionToken: tempCreds.sessionToken(),
            region: region,
            ecrPublic: isEcrPublic(registry)
        )

        // Get ECR authorization token using temporary credentials
        String ecrToken = getEcrAuthToken(awsCreds)

        // Create cached entry
        return new CachedEcrCredentials(
            accessKeyId: tempCreds.accessKeyId(),
            secretAccessKey: tempCreds.secretAccessKey(),
            sessionToken: tempCreds.sessionToken(),
            stsExpiration: tempCreds.expiration(),
            authToken: ecrToken,
            tokenExpiration: Instant.now().plus(Duration.ofHours(12))
        )
    }

    // Check if credentials are expiring and invalidate if needed
    if (cached.isExpiring()) {
        ecrCache.invalidate(creds.stableHash())
        return getLoginTokenWithRole(registry, roleArn, externalId)  // Retry
    }

    return cached.authToken
}

private String getLoginTokenWithStaticCredentials(String registry, String accessKey, String secretKey) {
    // Existing implementation unchanged
    // ...
}
```

**Test Coverage**:
- Integration test: End-to-end authentication with role ARN
- Integration test: Cached credentials reused on second request
- Integration test: Expired credentials automatically refreshed
- Integration test: Static credentials still work (backward compatibility)

---

### Phase 2: Error Handling & Logging

**Goal**: Comprehensive error handling and observability

#### Task 2.1: Add Metrics

**File**: `src/main/groovy/io/seqera/wave/service/aws/AwsEcrService.groovy`

**Implementation**:
```groovy
import io.micrometer.core.annotation.Timed
import io.micrometer.core.annotation.Counted

@Timed(value = "wave.sts.assume_role", description = "STS AssumeRole duration")
@Counted(value = "wave.sts.assume_role.calls", extraTags = ["result", "success"])
private AssumeRoleResponse assumeRole(String roleArn, String externalId, String sessionName) {
    // ... existing implementation
}

@Timed(value = "wave.ecr.get_login_token", description = "ECR authentication duration")
String getLoginToken(String registry, String username, String password) {
    // ... existing implementation
}
```

**Additional Metrics**:
- `wave.ecr.auth.cache.hit_rate` - Gauge for cache hit rate
- `wave.ecr.credentials.expiring_soon` - Gauge for credentials expiring in <5 min
- `wave.ecr.auth.method` - Counter with tags: static/role

---

#### Task 2.2: Add Structured Logging

**File**: `src/main/groovy/io/seqera/wave/service/aws/AwsEcrService.groovy`

**Implementation**:
```groovy
private AssumeRoleResponse assumeRole(String roleArn, String externalId, String sessionName) {
    log.info("Assuming IAM role: {} with session: {}", roleArn, sessionName)

    try {
        AssumeRoleResponse response = stsClient.assumeRole(request)
        Credentials creds = response.credentials()

        log.info("Successfully assumed role: {}. Credentials expire at: {}",
            roleArn, creds.expiration())

        return response
    } catch (StsException e) {
        log.error("Failed to assume role: {}. Error: {} - {}",
            roleArn,
            e.awsErrorDetails().errorCode(),
            e.awsErrorDetails().errorMessage())

        throw mapStsException(e, roleArn)
    }
}
```

**Logging Guidelines**:
- Never log `secretAccessKey` or `sessionToken` in plaintext
- Use structured logging with meaningful context
- Log all STS calls at INFO level for audit trail
- Log cache hits/misses at DEBUG level

---

### Phase 3: Testing

**Goal**: Comprehensive test coverage for all scenarios

#### Task 3.1: Unit Tests

**File**: `src/test/groovy/io/seqera/wave/service/aws/AwsEcrServiceSpec.groovy`

**Test Cases**:
```groovy
class AwsEcrServiceSpec extends Specification {

    def "should detect role ARN pattern"() {
        given:
        def service = new AwsEcrService()

        expect:
        service.isRoleArn('arn:aws:iam::123456789012:role/MyRole') == true
        service.isRoleArn('AKIAIOSFODNN7EXAMPLE') == false
    }

    def "should call STS AssumeRole for role ARN"() {
        given:
        def stsClient = Mock(StsClient)
        def service = new AwsEcrService(stsClient: stsClient)

        when:
        service.getLoginToken(registry, roleArn, externalId)

        then:
        1 * stsClient.assumeRole(_) >> mockAssumeRoleResponse()
    }

    def "should use static credentials for access key"() {
        given:
        def stsClient = Mock(StsClient)
        def service = new AwsEcrService(stsClient: stsClient)

        when:
        service.getLoginToken(registry, accessKey, secretKey)

        then:
        0 * stsClient.assumeRole(_)
    }

    def "should generate correct session name format"() {
        given:
        def service = new AwsEcrService()

        when:
        def sessionName = service.generateSessionName('123456789012.dkr.ecr.us-east-1.amazonaws.com')

        then:
        sessionName ==~ /wave-ecr-123456789012-\d+/
    }

    def "should map STS exceptions correctly"() {
        given:
        def service = new AwsEcrService()
        def stsException = createStsException('AccessDenied', 'Not authorized')

        when:
        service.mapStsException(stsException, roleArn)

        then:
        thrown(UnauthorizedException)
    }
}
```

---

#### Task 3.2: Cache Tests

**File**: `src/test/groovy/io/seqera/wave/service/aws/cache/AwsEcrCacheSpec.groovy`

**Test Cases**:
```groovy
class AwsEcrCacheSpec extends Specification {

    def "should invalidate expiring STS credentials"() {
        given:
        def cache = new AwsEcrCache()
        def expiration = Instant.now().plus(Duration.ofMinutes(4))
        def cached = new CachedEcrCredentials(
            stsExpiration: expiration,
            tokenExpiration: Instant.now().plus(Duration.ofHours(12))
        )

        expect:
        cached.isExpiring() == true
    }

    def "should not invalidate credentials with >5 min remaining"() {
        given:
        def cache = new AwsEcrCache()
        def expiration = Instant.now().plus(Duration.ofMinutes(30))
        def cached = new CachedEcrCredentials(
            stsExpiration: expiration,
            tokenExpiration: Instant.now().plus(Duration.ofHours(12))
        )

        expect:
        cached.isExpiring() == false
    }

    def "should use earliest expiration"() {
        given:
        def stsExp = Instant.now().plus(Duration.ofMinutes(30))
        def tokenExp = Instant.now().plus(Duration.ofHours(12))
        def cached = new CachedEcrCredentials(
            stsExpiration: stsExp,
            tokenExpiration: tokenExp
        )

        expect:
        cached.getEffectiveExpiration() == stsExp
    }
}
```

---

#### Task 3.3: Integration Tests

**File**: `src/test/groovy/io/seqera/wave/service/aws/AwsEcrIntegrationSpec.groovy`

**Test Cases**:
```groovy
@MicronautTest
class AwsEcrIntegrationSpec extends Specification {

    @Inject
    AwsEcrService ecrService

    def "should authenticate with role ARN end-to-end"() {
        given:
        def registry = '123456789012.dkr.ecr.us-east-1.amazonaws.com'
        def roleArn = 'arn:aws:iam::123456789012:role/WaveEcrAccess'
        def externalId = UUID.randomUUID().toString()

        when:
        def token = ecrService.getLoginToken(registry, roleArn, externalId)

        then:
        token != null
        token.startsWith('AWS:')
    }

    def "should cache credentials and reuse on second request"() {
        given:
        def registry = '123456789012.dkr.ecr.us-east-1.amazonaws.com'
        def roleArn = 'arn:aws:iam::123456789012:role/WaveEcrAccess'
        def externalId = UUID.randomUUID().toString()

        when:
        def token1 = ecrService.getLoginToken(registry, roleArn, externalId)
        def token2 = ecrService.getLoginToken(registry, roleArn, externalId)

        then:
        token1 == token2  // Same token = cache hit
        // Verify only 1 STS call made (check logs or metrics)
    }
}
```

---

#### Task 3.4: Backward Compatibility Tests

**File**: `src/test/groovy/io/seqera/wave/service/aws/BackwardCompatibilitySpec.groovy` (NEW)

**Test Cases**:
```groovy
class BackwardCompatibilitySpec extends Specification {

    def "existing static credential tests should pass unchanged"() {
        // Run all existing AwsEcrServiceSpec tests
        // Verify no regressions
    }

    def "mixed authentication methods should work"() {
        given:
        def service = new AwsEcrService()

        when:
        def token1 = service.getLoginToken(registry, roleArn, externalId)
        def token2 = service.getLoginToken(registry, accessKey, secretKey)

        then:
        token1 != null
        token2 != null
    }
}
```

---

### Phase 4: Documentation

**Goal**: Complete customer and developer documentation

#### Task 4.1: Customer Documentation

**File**: `docs/ecr-iam-role-setup.md` (NEW)

**Sections**:
1. Overview of IAM role authentication benefits
2. Prerequisites (AWS account, IAM permissions)
3. Step-by-step IAM role creation
4. Trust policy configuration with external ID
5. Permissions policy for ECR access
6. Configuring credentials in Platform
7. Verification steps
8. Troubleshooting guide

---

#### Task 4.2: Developer Documentation

**File**: `docs/development/sts-integration.md` (NEW)

**Sections**:
1. Architecture overview
2. Code structure and key classes
3. Testing locally
4. Debugging tips
5. Metrics and monitoring
6. Performance tuning

---

#### Task 4.3: Update CHANGELOG

**File**: `changelog.txt`

**Entry**:
```
## [VERSION] - [DATE]

### Added
- IAM role-based authentication for AWS ECR registries via STS AssumeRole
- Automatic credential refresh with 5-minute expiration buffer
- External ID support for preventing confused deputy attacks
- Comprehensive error handling for STS authentication failures
- Metrics for STS authentication performance and cache hit rate

### Changed
- Extended AwsCreds and CachedEcrCredentials to support session tokens
- Enhanced credential caching to track STS credential expiration

### Fixed
- N/A (new feature)

### Security
- Added external ID requirement for role-based authentication
- Credentials automatically refresh before expiration
- All STS operations logged for audit trail
```

---

## Success Criteria

### Functional Requirements ✅

| Requirement | Acceptance Criteria | Status |
|-------------|---------------------|--------|
| FR-001: Role ARN detection | `isRoleArn()` correctly identifies role ARN pattern | To be tested |
| FR-002: Backward compatibility | Static credentials work unchanged | To be tested |
| FR-003: External ID generation | Platform auto-generates UUID (Platform change) | Platform scope |
| FR-004: External ID in STS calls | AssumeRole includes external ID | To be tested |
| FR-005: 1-hour session duration | AssumeRole requests 3600 seconds | To be tested |
| FR-006: Session token storage | CachedEcrCredentials includes session token | To be tested |
| FR-007: Session token in API calls | ECR calls include session token | To be tested |
| FR-008: Credential caching | Cache hit rate >95% | To be load tested |
| FR-009: Automatic refresh | Credentials refresh 5 min before expiration | To be tested |
| FR-010: Cache invalidation | Expiring credentials removed from cache | To be tested |
| FR-011: Retry on expiration | ExpiredTokenException triggers retry | To be tested |
| FR-012: Error messages | Specific messages for STS errors | To be tested |
| FR-017: Unique cache key | Session token in cache key hash | To be tested |
| FR-019: Session name format | `wave-ecr-{account}-{timestamp}` | To be tested |
| FR-020: Logging | All STS calls logged with context | To be tested |

### Non-Functional Requirements ✅

| Requirement | Acceptance Criteria | Status |
|-------------|---------------------|--------|
| NFR-001: STS success rate | >99.9% (excluding customer errors) | To be monitored |
| NFR-002: Cache hit rate | >95% | To be load tested |
| NFR-003: Credential refresh | <2 seconds (p95) | To be tested |
| NFR-004: Concurrent sessions | 1000+ without degradation | To be load tested |
| NFR-005: Zero-downtime deployment | Static credentials work after deployment | To be tested |
| NFR-006: No credential logging | Secrets redacted in logs | To be tested |
| NFR-007: Secure external ID | UUID v4 generation (Platform scope) | Platform scope |
| NFR-008: Audit trail | CloudTrail tracks all AssumeRole | AWS-provided |

---

## Risk Mitigation

### Risk 1: STS Rate Limiting

**Mitigation**: Aggressive caching (1-hour sessions, 5-min buffer) reduces STS calls to <1 per hour per customer

**Monitoring**: Track `wave.sts.assume_role.calls` metric, alert if rate exceeds threshold

---

### Risk 2: Credential Expiration During Operations

**Mitigation**: 5-minute refresh buffer, automatic retry with fresh credentials on ExpiredTokenException

**Testing**: Integration test with 15-minute session duration to verify refresh behavior

---

### Risk 3: Backward Compatibility Break

**Mitigation**: Extensive testing, feature flag for gradual rollout (optional), automated backward compatibility tests

**Rollback Plan**: Revert to previous version if compatibility issues detected (deploy takes <5 minutes)

---

### Risk 4: Performance Degradation

**Mitigation**: Load testing before production deployment, cache optimization, optional async STS calls

**Monitoring**: Track latency metrics, cache hit rate, alert on degradation

---

## Open Questions

1. **Q**: Should we support configurable session duration?
   **A**: No for MVP. Fixed 1-hour provides good balance. Can add later if requested.

2. **Q**: Should we implement regional STS endpoints?
   **A**: No for MVP. Global endpoint works for all regions. Optimize later if latency is issue.

3. **Q**: Should external ID be rotatable?
   **A**: No for MVP. Immutable after creation reduces complexity. Revisit if customers request.

4. **Q**: Should we persist cache across restarts?
   **A**: No for MVP. In-memory cache simplifies implementation. Evaluate Redis-backed cache if restart impact significant.

---

## References

- [Spec Document](./spec.md) - User stories and requirements
- [Research](./research.md) - Technology choices and architecture decisions
- [Data Model](./data-model.md) - AwsCreds and CachedEcrCredentials changes
- [Contracts](./contracts/) - STS and service interface contracts
- [Quickstart](./quickstart.md) - Developer setup and testing guide
- [AWS STS API](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html)
- [Wave Constitution](/.specify/memory/constitution.md) - v1.0.0
- [Wave CLAUDE.md](/CLAUDE.md) - Project conventions

---

**Plan Status**: ✅ Ready for implementation
**Next Step**: Run `/speckit.tasks` to generate task breakdown