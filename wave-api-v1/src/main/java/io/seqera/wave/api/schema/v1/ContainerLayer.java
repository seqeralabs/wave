/*
 * Wave API
 * Wave Containers Provisioning Service API A comprehensive container orchestration and build service
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package io.seqera.wave.api.schema.v1;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;
import com.fasterxml.jackson.annotation.*;
import jakarta.validation.constraints.*;
import jakarta.validation.Valid;
import io.micronaut.core.annotation.Introspected;
import io.micronaut.core.annotation.Nullable;
import jakarta.annotation.Generated;

/**
 * Container layer meta-info
 */
@JsonPropertyOrder({
    ContainerLayer.JSON_PROPERTY_LOCATION,
    ContainerLayer.JSON_PROPERTY_GZIP_DIGEST,
    ContainerLayer.JSON_PROPERTY_GZIP_SIZE,
    ContainerLayer.JSON_PROPERTY_TAR_DIGEST,
    ContainerLayer.JSON_PROPERTY_SKIP_HASHING,
})
@Generated("io.micronaut.openapi.generator.JavaMicronautServerCodegen")
@Introspected
public class ContainerLayer {

    public static final String JSON_PROPERTY_LOCATION = "location";
    public static final String JSON_PROPERTY_GZIP_DIGEST = "gzipDigest";
    public static final String JSON_PROPERTY_GZIP_SIZE = "gzipSize";
    public static final String JSON_PROPERTY_TAR_DIGEST = "tarDigest";
    public static final String JSON_PROPERTY_SKIP_HASHING = "skipHashing";

    /**
     * The layer location, it can be either &#x60;http:&#x60; or &#x60;https:&#x60; prefixed URI or a &#x60;data:&#x60; pseudo-protocol followed by a base64 encoded tar gzipped layer payload
     */
    @NotNull
    @JsonProperty(JSON_PROPERTY_LOCATION)
    private String location;

    /**
     * The layer gzip sha256 checksum
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_GZIP_DIGEST)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String gzipDigest;

    /**
     * The layer gzip size in bytes
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_GZIP_SIZE)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private Integer gzipSize;

    /**
     * The layer tar sha256 checksum
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_TAR_DIGEST)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String tarDigest;

    /**
     * When true, this layer is not added in the final config fingerprint
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_SKIP_HASHING)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private Boolean skipHashing;

    private ContainerLayer() {
    }

    public ContainerLayer(String location) {
        this.location = location;
    }

    /**
     * The layer location, it can be either &#x60;http:&#x60; or &#x60;https:&#x60; prefixed URI or a &#x60;data:&#x60; pseudo-protocol followed by a base64 encoded tar gzipped layer payload
     *
     * @return the location property value
     */
    public String getLocation() {
        return location;
    }

    /**
     * Set the location property value
     *
     * @param location property value to set
     */
    public void setLocation(String location) {
        this.location = location;
    }

    /**
     * Set location in a chainable fashion.
     *
     * @return The same instance of ContainerLayer for chaining.
     */
    public ContainerLayer location(String location) {
        this.location = location;
        return this;
    }

    /**
     * The layer gzip sha256 checksum
     *
     * @return the gzipDigest property value
     */
    public String getGzipDigest() {
        return gzipDigest;
    }

    /**
     * Set the gzipDigest property value
     *
     * @param gzipDigest property value to set
     */
    public void setGzipDigest(String gzipDigest) {
        this.gzipDigest = gzipDigest;
    }

    /**
     * Set gzipDigest in a chainable fashion.
     *
     * @return The same instance of ContainerLayer for chaining.
     */
    public ContainerLayer gzipDigest(String gzipDigest) {
        this.gzipDigest = gzipDigest;
        return this;
    }

    /**
     * The layer gzip size in bytes
     *
     * @return the gzipSize property value
     */
    public Integer getGzipSize() {
        return gzipSize;
    }

    /**
     * Set the gzipSize property value
     *
     * @param gzipSize property value to set
     */
    public void setGzipSize(Integer gzipSize) {
        this.gzipSize = gzipSize;
    }

    /**
     * Set gzipSize in a chainable fashion.
     *
     * @return The same instance of ContainerLayer for chaining.
     */
    public ContainerLayer gzipSize(Integer gzipSize) {
        this.gzipSize = gzipSize;
        return this;
    }

    /**
     * The layer tar sha256 checksum
     *
     * @return the tarDigest property value
     */
    public String getTarDigest() {
        return tarDigest;
    }

    /**
     * Set the tarDigest property value
     *
     * @param tarDigest property value to set
     */
    public void setTarDigest(String tarDigest) {
        this.tarDigest = tarDigest;
    }

    /**
     * Set tarDigest in a chainable fashion.
     *
     * @return The same instance of ContainerLayer for chaining.
     */
    public ContainerLayer tarDigest(String tarDigest) {
        this.tarDigest = tarDigest;
        return this;
    }

    /**
     * When true, this layer is not added in the final config fingerprint
     *
     * @return the skipHashing property value
     */
    public Boolean getSkipHashing() {
        return skipHashing;
    }

    /**
     * Set the skipHashing property value
     *
     * @param skipHashing property value to set
     */
    public void setSkipHashing(Boolean skipHashing) {
        this.skipHashing = skipHashing;
    }

    /**
     * Set skipHashing in a chainable fashion.
     *
     * @return The same instance of ContainerLayer for chaining.
     */
    public ContainerLayer skipHashing(Boolean skipHashing) {
        this.skipHashing = skipHashing;
        return this;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        var containerLayer = (ContainerLayer) o;
        return Objects.equals(location, containerLayer.location)
            && Objects.equals(gzipDigest, containerLayer.gzipDigest)
            && Objects.equals(gzipSize, containerLayer.gzipSize)
            && Objects.equals(tarDigest, containerLayer.tarDigest)
            && Objects.equals(skipHashing, containerLayer.skipHashing);
    }

    @Override
    public int hashCode() {
        return Objects.hash(location, gzipDigest, gzipSize, tarDigest, skipHashing);
    }

    @Override
    public String toString() {
        return "ContainerLayer("
            + "location: " + getLocation() + ", "
            + "gzipDigest: " + getGzipDigest() + ", "
            + "gzipSize: " + getGzipSize() + ", "
            + "tarDigest: " + getTarDigest() + ", "
            + "skipHashing: " + getSkipHashing()
            + ")";
    }

}