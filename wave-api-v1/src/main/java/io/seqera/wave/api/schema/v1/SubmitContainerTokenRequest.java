/*
 * Wave API
 * Wave Containers Provisioning Service API A comprehensive container orchestration and build service
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package io.seqera.wave.api.schema.v1;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;
import io.seqera.wave.api.schema.v1.BuildCompression;
import io.seqera.wave.api.schema.v1.BuildContext;
import io.seqera.wave.api.schema.v1.ContainerConfig;
import io.seqera.wave.api.schema.v1.ImageNameStrategy;
import io.seqera.wave.api.schema.v1.PackagesSpec;
import io.seqera.wave.api.schema.v1.ScanLevel;
import io.seqera.wave.api.schema.v1.ScanMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.*;
import jakarta.validation.constraints.*;
import jakarta.validation.Valid;
import io.micronaut.core.annotation.Introspected;
import io.micronaut.core.annotation.Nullable;
import jakarta.annotation.Generated;

/**
 * Submit container token request
 */
@JsonPropertyOrder({
    SubmitContainerTokenRequest.JSON_PROPERTY_TOWER_ACCESS_TOKEN,
    SubmitContainerTokenRequest.JSON_PROPERTY_TOWER_REFRESH_TOKEN,
    SubmitContainerTokenRequest.JSON_PROPERTY_TOWER_ENDPOINT,
    SubmitContainerTokenRequest.JSON_PROPERTY_TOWER_WORKSPACE_ID,
    SubmitContainerTokenRequest.JSON_PROPERTY_CONTAINER_IMAGE,
    SubmitContainerTokenRequest.JSON_PROPERTY_CONTAINER_FILE,
    SubmitContainerTokenRequest.JSON_PROPERTY_CONTAINER_CONFIG,
    SubmitContainerTokenRequest.JSON_PROPERTY_CONDA_FILE,
    SubmitContainerTokenRequest.JSON_PROPERTY_CONTAINER_PLATFORM,
    SubmitContainerTokenRequest.JSON_PROPERTY_BUILD_REPOSITORY,
    SubmitContainerTokenRequest.JSON_PROPERTY_CACHE_REPOSITORY,
    SubmitContainerTokenRequest.JSON_PROPERTY_TIMESTAMP,
    SubmitContainerTokenRequest.JSON_PROPERTY_FINGERPRINT,
    SubmitContainerTokenRequest.JSON_PROPERTY_FREEZE,
    SubmitContainerTokenRequest.JSON_PROPERTY_BUILD_CONTEXT,
    SubmitContainerTokenRequest.JSON_PROPERTY_FORMAT,
    SubmitContainerTokenRequest.JSON_PROPERTY_DRY_RUN,
    SubmitContainerTokenRequest.JSON_PROPERTY_WORKFLOW_ID,
    SubmitContainerTokenRequest.JSON_PROPERTY_CONTAINER_INCLUDES,
    SubmitContainerTokenRequest.JSON_PROPERTY_PACKAGES,
    SubmitContainerTokenRequest.JSON_PROPERTY_NAME_STRATEGY,
    SubmitContainerTokenRequest.JSON_PROPERTY_MIRROR,
    SubmitContainerTokenRequest.JSON_PROPERTY_SCAN_MODE,
    SubmitContainerTokenRequest.JSON_PROPERTY_SCAN_LEVELS,
    SubmitContainerTokenRequest.JSON_PROPERTY_BUILD_COMPRESSION,
})
@Generated("io.micronaut.openapi.generator.JavaMicronautServerCodegen")
@Introspected
public class SubmitContainerTokenRequest {

    public static final String JSON_PROPERTY_TOWER_ACCESS_TOKEN = "towerAccessToken";
    public static final String JSON_PROPERTY_TOWER_REFRESH_TOKEN = "towerRefreshToken";
    public static final String JSON_PROPERTY_TOWER_ENDPOINT = "towerEndpoint";
    public static final String JSON_PROPERTY_TOWER_WORKSPACE_ID = "towerWorkspaceId";
    public static final String JSON_PROPERTY_CONTAINER_IMAGE = "containerImage";
    public static final String JSON_PROPERTY_CONTAINER_FILE = "containerFile";
    public static final String JSON_PROPERTY_CONTAINER_CONFIG = "containerConfig";
    public static final String JSON_PROPERTY_CONDA_FILE = "condaFile";
    public static final String JSON_PROPERTY_CONTAINER_PLATFORM = "containerPlatform";
    public static final String JSON_PROPERTY_BUILD_REPOSITORY = "buildRepository";
    public static final String JSON_PROPERTY_CACHE_REPOSITORY = "cacheRepository";
    public static final String JSON_PROPERTY_TIMESTAMP = "timestamp";
    public static final String JSON_PROPERTY_FINGERPRINT = "fingerprint";
    public static final String JSON_PROPERTY_FREEZE = "freeze";
    public static final String JSON_PROPERTY_BUILD_CONTEXT = "buildContext";
    public static final String JSON_PROPERTY_FORMAT = "format";
    public static final String JSON_PROPERTY_DRY_RUN = "dryRun";
    public static final String JSON_PROPERTY_WORKFLOW_ID = "workflowId";
    public static final String JSON_PROPERTY_CONTAINER_INCLUDES = "containerIncludes";
    public static final String JSON_PROPERTY_PACKAGES = "packages";
    public static final String JSON_PROPERTY_NAME_STRATEGY = "nameStrategy";
    public static final String JSON_PROPERTY_MIRROR = "mirror";
    public static final String JSON_PROPERTY_SCAN_MODE = "scanMode";
    public static final String JSON_PROPERTY_SCAN_LEVELS = "scanLevels";
    public static final String JSON_PROPERTY_BUILD_COMPRESSION = "buildCompression";

    /**
     * Tower access token required to enable the service
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_TOWER_ACCESS_TOKEN)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String towerAccessToken;

    /**
     * Tower refresh token used to refresh the authorization
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_TOWER_REFRESH_TOKEN)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String towerRefreshToken;

    /**
     * Tower endpoint: the public address of the tower instance to integrate with wave
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_TOWER_ENDPOINT)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String towerEndpoint;

    /**
     * Tower workspace id
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_TOWER_WORKSPACE_ID)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private Long towerWorkspaceId;

    /**
     * Container image to be pulled
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_CONTAINER_IMAGE)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String containerImage;

    /**
     * Container build file i.g. Dockerfile of the container to be build
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_CONTAINER_FILE)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String containerFile;

    /**
     * List of layers to be added in the pulled image
     */
    @Nullable(inherited = true)
    @Valid
    @JsonProperty(JSON_PROPERTY_CONTAINER_CONFIG)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private ContainerConfig containerConfig;

    /**
     * Conda recipe file used to build the container
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_CONDA_FILE)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String condaFile;

    /**
     * The container platform to be used
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_CONTAINER_PLATFORM)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String containerPlatform;

    /**
     * The repository where the build container should be pushed
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_BUILD_REPOSITORY)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String buildRepository;

    /**
     * The repository where the build container should be pushed
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_CACHE_REPOSITORY)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String cacheRepository;

    /**
     * Request timestamp
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_TIMESTAMP)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String timestamp;

    /**
     * Request unique fingerprint
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_FINGERPRINT)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String fingerprint;

    /**
     * Enable freeze mode that cause the container build to include all containerConfig dependencies
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_FREEZE)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private Boolean freeze = false;

    /**
     * A layer holding the build context for this container request
     */
    @Nullable(inherited = true)
    @Valid
    @JsonProperty(JSON_PROPERTY_BUILD_CONTEXT)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private BuildContext buildContext;

    /**
     * Format of the target container build. Use &#x60;sif&#x60; for Singularity. default: docker/oci
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_FORMAT)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String format;

    /**
     * When true build requests are carried out in dry-run mode
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_DRY_RUN)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private Boolean dryRun;

    /**
     * Id of workflow in tower
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_WORKFLOW_ID)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private String workflowId;

    /**
     * One or more container should be included in upstream container request
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_CONTAINER_INCLUDES)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private List<@NotNull String> containerIncludes;

    /**
     * Defines the packages to be included in this container request
     */
    @Nullable(inherited = true)
    @Valid
    @JsonProperty(JSON_PROPERTY_PACKAGES)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private PackagesSpec packages;

    /**
     * The strategy applied to name a container build by wave when using the freeze option
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_NAME_STRATEGY)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private ImageNameStrategy nameStrategy;

    /**
     * Whenever use container \&quot;mirror\&quot; mode
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_MIRROR)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private Boolean mirror = false;

    /**
     * The request security scan mode
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_SCAN_MODE)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private ScanMode scanMode;

    /**
     * Define the allows security vulnerabilities in the container request
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_SCAN_LEVELS)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private List<ScanLevel> scanLevels;

    /**
     * The compression mode to be used when building a container image
     */
    @Nullable(inherited = true)
    @JsonProperty(JSON_PROPERTY_BUILD_COMPRESSION)
    @JsonInclude(JsonInclude.Include.USE_DEFAULTS)
    private BuildCompression buildCompression;

    /**
     * Tower access token required to enable the service
     *
     * @return the towerAccessToken property value
     */
    public String getTowerAccessToken() {
        return towerAccessToken;
    }

    /**
     * Set the towerAccessToken property value
     *
     * @param towerAccessToken property value to set
     */
    public void setTowerAccessToken(String towerAccessToken) {
        this.towerAccessToken = towerAccessToken;
    }

    /**
     * Set towerAccessToken in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest towerAccessToken(String towerAccessToken) {
        this.towerAccessToken = towerAccessToken;
        return this;
    }

    /**
     * Tower refresh token used to refresh the authorization
     *
     * @return the towerRefreshToken property value
     */
    public String getTowerRefreshToken() {
        return towerRefreshToken;
    }

    /**
     * Set the towerRefreshToken property value
     *
     * @param towerRefreshToken property value to set
     */
    public void setTowerRefreshToken(String towerRefreshToken) {
        this.towerRefreshToken = towerRefreshToken;
    }

    /**
     * Set towerRefreshToken in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest towerRefreshToken(String towerRefreshToken) {
        this.towerRefreshToken = towerRefreshToken;
        return this;
    }

    /**
     * Tower endpoint: the public address of the tower instance to integrate with wave
     *
     * @return the towerEndpoint property value
     */
    public String getTowerEndpoint() {
        return towerEndpoint;
    }

    /**
     * Set the towerEndpoint property value
     *
     * @param towerEndpoint property value to set
     */
    public void setTowerEndpoint(String towerEndpoint) {
        this.towerEndpoint = towerEndpoint;
    }

    /**
     * Set towerEndpoint in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest towerEndpoint(String towerEndpoint) {
        this.towerEndpoint = towerEndpoint;
        return this;
    }

    /**
     * Tower workspace id
     *
     * @return the towerWorkspaceId property value
     */
    public Long getTowerWorkspaceId() {
        return towerWorkspaceId;
    }

    /**
     * Set the towerWorkspaceId property value
     *
     * @param towerWorkspaceId property value to set
     */
    public void setTowerWorkspaceId(Long towerWorkspaceId) {
        this.towerWorkspaceId = towerWorkspaceId;
    }

    /**
     * Set towerWorkspaceId in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest towerWorkspaceId(Long towerWorkspaceId) {
        this.towerWorkspaceId = towerWorkspaceId;
        return this;
    }

    /**
     * Container image to be pulled
     *
     * @return the containerImage property value
     */
    public String getContainerImage() {
        return containerImage;
    }

    /**
     * Set the containerImage property value
     *
     * @param containerImage property value to set
     */
    public void setContainerImage(String containerImage) {
        this.containerImage = containerImage;
    }

    /**
     * Set containerImage in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest containerImage(String containerImage) {
        this.containerImage = containerImage;
        return this;
    }

    /**
     * Container build file i.g. Dockerfile of the container to be build
     *
     * @return the containerFile property value
     */
    public String getContainerFile() {
        return containerFile;
    }

    /**
     * Set the containerFile property value
     *
     * @param containerFile property value to set
     */
    public void setContainerFile(String containerFile) {
        this.containerFile = containerFile;
    }

    /**
     * Set containerFile in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest containerFile(String containerFile) {
        this.containerFile = containerFile;
        return this;
    }

    /**
     * List of layers to be added in the pulled image
     *
     * @return the containerConfig property value
     */
    public ContainerConfig getContainerConfig() {
        return containerConfig;
    }

    /**
     * Set the containerConfig property value
     *
     * @param containerConfig property value to set
     */
    public void setContainerConfig(ContainerConfig containerConfig) {
        this.containerConfig = containerConfig;
    }

    /**
     * Set containerConfig in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest containerConfig(ContainerConfig containerConfig) {
        this.containerConfig = containerConfig;
        return this;
    }

    /**
     * Conda recipe file used to build the container
     *
     * @return the condaFile property value
     */
    public String getCondaFile() {
        return condaFile;
    }

    /**
     * Set the condaFile property value
     *
     * @param condaFile property value to set
     */
    public void setCondaFile(String condaFile) {
        this.condaFile = condaFile;
    }

    /**
     * Set condaFile in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest condaFile(String condaFile) {
        this.condaFile = condaFile;
        return this;
    }

    /**
     * The container platform to be used
     *
     * @return the containerPlatform property value
     */
    public String getContainerPlatform() {
        return containerPlatform;
    }

    /**
     * Set the containerPlatform property value
     *
     * @param containerPlatform property value to set
     */
    public void setContainerPlatform(String containerPlatform) {
        this.containerPlatform = containerPlatform;
    }

    /**
     * Set containerPlatform in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest containerPlatform(String containerPlatform) {
        this.containerPlatform = containerPlatform;
        return this;
    }

    /**
     * The repository where the build container should be pushed
     *
     * @return the buildRepository property value
     */
    public String getBuildRepository() {
        return buildRepository;
    }

    /**
     * Set the buildRepository property value
     *
     * @param buildRepository property value to set
     */
    public void setBuildRepository(String buildRepository) {
        this.buildRepository = buildRepository;
    }

    /**
     * Set buildRepository in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest buildRepository(String buildRepository) {
        this.buildRepository = buildRepository;
        return this;
    }

    /**
     * The repository where the build container should be pushed
     *
     * @return the cacheRepository property value
     */
    public String getCacheRepository() {
        return cacheRepository;
    }

    /**
     * Set the cacheRepository property value
     *
     * @param cacheRepository property value to set
     */
    public void setCacheRepository(String cacheRepository) {
        this.cacheRepository = cacheRepository;
    }

    /**
     * Set cacheRepository in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest cacheRepository(String cacheRepository) {
        this.cacheRepository = cacheRepository;
        return this;
    }

    /**
     * Request timestamp
     *
     * @return the timestamp property value
     */
    public String getTimestamp() {
        return timestamp;
    }

    /**
     * Set the timestamp property value
     *
     * @param timestamp property value to set
     */
    public void setTimestamp(String timestamp) {
        this.timestamp = timestamp;
    }

    /**
     * Set timestamp in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest timestamp(String timestamp) {
        this.timestamp = timestamp;
        return this;
    }

    /**
     * Request unique fingerprint
     *
     * @return the fingerprint property value
     */
    public String getFingerprint() {
        return fingerprint;
    }

    /**
     * Set the fingerprint property value
     *
     * @param fingerprint property value to set
     */
    public void setFingerprint(String fingerprint) {
        this.fingerprint = fingerprint;
    }

    /**
     * Set fingerprint in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest fingerprint(String fingerprint) {
        this.fingerprint = fingerprint;
        return this;
    }

    /**
     * Enable freeze mode that cause the container build to include all containerConfig dependencies
     *
     * @return the freeze property value
     */
    public Boolean getFreeze() {
        return freeze;
    }

    /**
     * Set the freeze property value
     *
     * @param freeze property value to set
     */
    public void setFreeze(Boolean freeze) {
        this.freeze = freeze;
    }

    /**
     * Set freeze in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest freeze(Boolean freeze) {
        this.freeze = freeze;
        return this;
    }

    /**
     * A layer holding the build context for this container request
     *
     * @return the buildContext property value
     */
    public BuildContext getBuildContext() {
        return buildContext;
    }

    /**
     * Set the buildContext property value
     *
     * @param buildContext property value to set
     */
    public void setBuildContext(BuildContext buildContext) {
        this.buildContext = buildContext;
    }

    /**
     * Set buildContext in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest buildContext(BuildContext buildContext) {
        this.buildContext = buildContext;
        return this;
    }

    /**
     * Format of the target container build. Use &#x60;sif&#x60; for Singularity. default: docker/oci
     *
     * @return the format property value
     */
    public String getFormat() {
        return format;
    }

    /**
     * Set the format property value
     *
     * @param format property value to set
     */
    public void setFormat(String format) {
        this.format = format;
    }

    /**
     * Set format in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest format(String format) {
        this.format = format;
        return this;
    }

    /**
     * When true build requests are carried out in dry-run mode
     *
     * @return the dryRun property value
     */
    public Boolean getDryRun() {
        return dryRun;
    }

    /**
     * Set the dryRun property value
     *
     * @param dryRun property value to set
     */
    public void setDryRun(Boolean dryRun) {
        this.dryRun = dryRun;
    }

    /**
     * Set dryRun in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest dryRun(Boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }

    /**
     * Id of workflow in tower
     *
     * @return the workflowId property value
     */
    public String getWorkflowId() {
        return workflowId;
    }

    /**
     * Set the workflowId property value
     *
     * @param workflowId property value to set
     */
    public void setWorkflowId(String workflowId) {
        this.workflowId = workflowId;
    }

    /**
     * Set workflowId in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest workflowId(String workflowId) {
        this.workflowId = workflowId;
        return this;
    }

    /**
     * One or more container should be included in upstream container request
     *
     * @return the containerIncludes property value
     */
    public List<@NotNull String> getContainerIncludes() {
        return containerIncludes;
    }

    /**
     * Set the containerIncludes property value
     *
     * @param containerIncludes property value to set
     */
    public void setContainerIncludes(List<@NotNull String> containerIncludes) {
        this.containerIncludes = containerIncludes;
    }

    /**
     * Set containerIncludes in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest containerIncludes(List<@NotNull String> containerIncludes) {
        this.containerIncludes = containerIncludes;
        return this;
    }
    /**
     * Add an item to the containerIncludes property in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest addContainerIncludesItem(String containerIncludesItem) {
        if (containerIncludes == null) {
            containerIncludes = new ArrayList<>();
        }
        containerIncludes.add(containerIncludesItem);
        return this;
    }

    /**
     * Defines the packages to be included in this container request
     *
     * @return the packages property value
     */
    public PackagesSpec getPackages() {
        return packages;
    }

    /**
     * Set the packages property value
     *
     * @param packages property value to set
     */
    public void setPackages(PackagesSpec packages) {
        this.packages = packages;
    }

    /**
     * Set packages in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest packages(PackagesSpec packages) {
        this.packages = packages;
        return this;
    }

    /**
     * The strategy applied to name a container build by wave when using the freeze option
     *
     * @return the nameStrategy property value
     */
    public ImageNameStrategy getNameStrategy() {
        return nameStrategy;
    }

    /**
     * Set the nameStrategy property value
     *
     * @param nameStrategy property value to set
     */
    public void setNameStrategy(ImageNameStrategy nameStrategy) {
        this.nameStrategy = nameStrategy;
    }

    /**
     * Set nameStrategy in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest nameStrategy(ImageNameStrategy nameStrategy) {
        this.nameStrategy = nameStrategy;
        return this;
    }

    /**
     * Whenever use container \&quot;mirror\&quot; mode
     *
     * @return the mirror property value
     */
    public Boolean getMirror() {
        return mirror;
    }

    /**
     * Set the mirror property value
     *
     * @param mirror property value to set
     */
    public void setMirror(Boolean mirror) {
        this.mirror = mirror;
    }

    /**
     * Set mirror in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest mirror(Boolean mirror) {
        this.mirror = mirror;
        return this;
    }

    /**
     * The request security scan mode
     *
     * @return the scanMode property value
     */
    public ScanMode getScanMode() {
        return scanMode;
    }

    /**
     * Set the scanMode property value
     *
     * @param scanMode property value to set
     */
    public void setScanMode(ScanMode scanMode) {
        this.scanMode = scanMode;
    }

    /**
     * Set scanMode in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest scanMode(ScanMode scanMode) {
        this.scanMode = scanMode;
        return this;
    }

    /**
     * Define the allows security vulnerabilities in the container request
     *
     * @return the scanLevels property value
     */
    public List<ScanLevel> getScanLevels() {
        return scanLevels;
    }

    /**
     * Set the scanLevels property value
     *
     * @param scanLevels property value to set
     */
    public void setScanLevels(List<ScanLevel> scanLevels) {
        this.scanLevels = scanLevels;
    }

    /**
     * Set scanLevels in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest scanLevels(List<ScanLevel> scanLevels) {
        this.scanLevels = scanLevels;
        return this;
    }
    /**
     * Add an item to the scanLevels property in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest addScanLevelsItem(ScanLevel scanLevelsItem) {
        if (scanLevels == null) {
            scanLevels = new ArrayList<>();
        }
        scanLevels.add(scanLevelsItem);
        return this;
    }

    /**
     * The compression mode to be used when building a container image
     *
     * @return the buildCompression property value
     */
    public BuildCompression getBuildCompression() {
        return buildCompression;
    }

    /**
     * Set the buildCompression property value
     *
     * @param buildCompression property value to set
     */
    public void setBuildCompression(BuildCompression buildCompression) {
        this.buildCompression = buildCompression;
    }

    /**
     * Set buildCompression in a chainable fashion.
     *
     * @return The same instance of SubmitContainerTokenRequest for chaining.
     */
    public SubmitContainerTokenRequest buildCompression(BuildCompression buildCompression) {
        this.buildCompression = buildCompression;
        return this;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        var submitContainerTokenRequest = (SubmitContainerTokenRequest) o;
        return Objects.equals(towerAccessToken, submitContainerTokenRequest.towerAccessToken)
            && Objects.equals(towerRefreshToken, submitContainerTokenRequest.towerRefreshToken)
            && Objects.equals(towerEndpoint, submitContainerTokenRequest.towerEndpoint)
            && Objects.equals(towerWorkspaceId, submitContainerTokenRequest.towerWorkspaceId)
            && Objects.equals(containerImage, submitContainerTokenRequest.containerImage)
            && Objects.equals(containerFile, submitContainerTokenRequest.containerFile)
            && Objects.equals(containerConfig, submitContainerTokenRequest.containerConfig)
            && Objects.equals(condaFile, submitContainerTokenRequest.condaFile)
            && Objects.equals(containerPlatform, submitContainerTokenRequest.containerPlatform)
            && Objects.equals(buildRepository, submitContainerTokenRequest.buildRepository)
            && Objects.equals(cacheRepository, submitContainerTokenRequest.cacheRepository)
            && Objects.equals(timestamp, submitContainerTokenRequest.timestamp)
            && Objects.equals(fingerprint, submitContainerTokenRequest.fingerprint)
            && Objects.equals(freeze, submitContainerTokenRequest.freeze)
            && Objects.equals(buildContext, submitContainerTokenRequest.buildContext)
            && Objects.equals(format, submitContainerTokenRequest.format)
            && Objects.equals(dryRun, submitContainerTokenRequest.dryRun)
            && Objects.equals(workflowId, submitContainerTokenRequest.workflowId)
            && Objects.equals(containerIncludes, submitContainerTokenRequest.containerIncludes)
            && Objects.equals(packages, submitContainerTokenRequest.packages)
            && Objects.equals(nameStrategy, submitContainerTokenRequest.nameStrategy)
            && Objects.equals(mirror, submitContainerTokenRequest.mirror)
            && Objects.equals(scanMode, submitContainerTokenRequest.scanMode)
            && Objects.equals(scanLevels, submitContainerTokenRequest.scanLevels)
            && Objects.equals(buildCompression, submitContainerTokenRequest.buildCompression);
    }

    @Override
    public int hashCode() {
        return Objects.hash(towerAccessToken, towerRefreshToken, towerEndpoint, towerWorkspaceId, containerImage, containerFile, containerConfig, condaFile, containerPlatform, buildRepository, cacheRepository, timestamp, fingerprint, freeze, buildContext, format, dryRun, workflowId, containerIncludes, packages, nameStrategy, mirror, scanMode, scanLevels, buildCompression);
    }

    @Override
    public String toString() {
        return "SubmitContainerTokenRequest("
            + "towerAccessToken: " + getTowerAccessToken() + ", "
            + "towerRefreshToken: " + getTowerRefreshToken() + ", "
            + "towerEndpoint: " + getTowerEndpoint() + ", "
            + "towerWorkspaceId: " + getTowerWorkspaceId() + ", "
            + "containerImage: " + getContainerImage() + ", "
            + "containerFile: " + getContainerFile() + ", "
            + "containerConfig: " + getContainerConfig() + ", "
            + "condaFile: " + getCondaFile() + ", "
            + "containerPlatform: " + getContainerPlatform() + ", "
            + "buildRepository: " + getBuildRepository() + ", "
            + "cacheRepository: " + getCacheRepository() + ", "
            + "timestamp: " + getTimestamp() + ", "
            + "fingerprint: " + getFingerprint() + ", "
            + "freeze: " + getFreeze() + ", "
            + "buildContext: " + getBuildContext() + ", "
            + "format: " + getFormat() + ", "
            + "dryRun: " + getDryRun() + ", "
            + "workflowId: " + getWorkflowId() + ", "
            + "containerIncludes: " + getContainerIncludes() + ", "
            + "packages: " + getPackages() + ", "
            + "nameStrategy: " + getNameStrategy() + ", "
            + "mirror: " + getMirror() + ", "
            + "scanMode: " + getScanMode() + ", "
            + "scanLevels: " + getScanLevels() + ", "
            + "buildCompression: " + getBuildCompression()
            + ")";
    }

}